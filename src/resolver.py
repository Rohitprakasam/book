"""
BookForge 4.0 â€” The Art Department (Phase 3)
==============================================
Post-processes the expanded manuscript by resolving placeholder tags:

    [ORIGINAL_ASSET: /assets/file.png]  â†’  ![Original Figure](/assets/file.png)
    [NEW_DIAGRAM: {...json...}]         â†’  ![AI Generated](/assets/ai_generated/file.png)

Usage
-----
    from src.resolver import process_art_department
    final_md = process_art_department(expanded_text, style_config={...})
"""

from __future__ import annotations

import os
import re
import json
from io import BytesIO
from pathlib import Path

# Try importing google-genai
try:
    from google import genai
    from google.genai import types
    from PIL import Image
    HAS_GENAI = True
except ImportError:
    HAS_GENAI = False

import litellm
from dotenv import load_dotenv

load_dotenv()

OUTPUT_DIR = Path("data/output")
RESOLVED_PATH = OUTPUT_DIR / "resolved_manuscript.md"
AI_ASSETS_DIR = OUTPUT_DIR / "assets" / "ai_generated"


def _get_model() -> str:
    """Return the model identifier from the environment."""
    return os.getenv("DEFAULT_MODEL", "groq/llama3-8b-8192")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TASK A: Resolve Original Asset Tags
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def resolve_original_assets(text: str) -> str:
    """
    Replace ``[ORIGINAL_ASSET: <filepath>]`` tags with
    standard Markdown image syntax.
    """
    pattern = r"\[ORIGINAL_ASSET:\s*(.+?)\]"

    def _replacer(match: re.Match) -> str:
        filepath = match.group(1).strip()
        # Ensure path is relative or absolute as needed
        return f"![Original Figure]({filepath})"

    resolved = re.sub(pattern, _replacer, text)
    original_count = len(re.findall(pattern, text))
    print(f"[Art Dept] Resolved {original_count} [ORIGINAL_ASSET] tag(s)")
    return resolved



# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TASK B: AI Image Generation (Imagen 3)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_image_gen_disabled = False  # Global flag to stop trying if model fails

def generate_nano_banana_image(subject: str, theme_config: dict, save_path: Path) -> bool:
    """
    Calls Google's image model to generate a stylized textbook illustration.
    """
    global _image_gen_disabled
    if not HAS_GENAI or _image_gen_disabled:
        if not HAS_GENAI:
            print("[Art Dept] âš ï¸ google-genai not installed. Skipping image generation.")
        return False

    client = genai.Client(api_key=os.getenv("GEMINI_API_KEY"))

    # Extract the illustration style generated by Phase 1
    style_prompt = theme_config.get(
        "illustration_style", 
        "Flat vector illustration, clean lines, white background, educational textbook graphic"
    )
    
    # Combine the Drafter's subject with the Style Extractor's visual rules
    full_prompt = f"{subject}. {style_prompt}. High quality, technical diagram."
    print(f"  ðŸŽ¨ Generating: \"{subject[:50]}â€¦\"")
    
    try:
    try:
        # User requested 'gemini-2.5-flash-image'. 
        # We'll use this exact model string as the default.
        target_model = os.getenv("IMAGE_MODEL", "gemini-2.5-flash-image")
        
        response = client.models.generate_images(
            model=target_model, 
            prompt=full_prompt,
            config=types.GenerateImagesConfig(
                number_of_images=1,
                aspect_ratio="16:9", 
                person_generation="DONT_ALLOW" 
            )
        )
        
        for generated_image in response.generated_images:
            image_bytes = generated_image.image.image_bytes
            image = Image.open(BytesIO(image_bytes))
            
            save_path.parent.mkdir(parents=True, exist_ok=True)
            image.save(save_path)
            return True
            
    except Exception as e:
        error_str = str(e)
        print(f"  âŒ Image Generation Failed: {error_str[:200]}...")
        
        # Check for 404 Model Not Found or Quota issues to fail fast
        if "404" in error_str or "NOT_FOUND" in error_str:
            print("  âš ï¸  Critical Model Error: Disabling further image generation for this run.")
            _image_gen_disabled = True
            
        return False
    
    return False


def resolve_art_tags(text: str, theme_config: dict = None) -> str:
    """
    Finds [NEW_DIAGRAM] JSON tags, generates images, and replaces tags with markdown links.
    """
    if theme_config is None:
        theme_config = {}

    pattern = r'\[NEW_DIAGRAM:\s*(\{.*?\})\s*\]'
    matches = list(re.finditer(pattern, text))

    if not matches:
        print("[Art Dept] No [NEW_DIAGRAM] tags found.")
        return text

    print(f"[Art Dept] Found {len(matches)} [NEW_DIAGRAM] tags â€” generating assetsâ€¦")
    AI_ASSETS_DIR.mkdir(parents=True, exist_ok=True)

    def replacement_func(match):
        try:
            art_request = json.loads(match.group(1))
            subject = art_request.get("subject", "Engineering diagram")
            
            # Create a safe filename
            safe_subject = re.sub(r'[^a-zA-Z0-9]', '_', subject)[:30]
            filename = f"ai_{safe_subject}.png"
            save_path = AI_ASSETS_DIR / filename
            
            # Check if exists to avoid re-gen (optional caching)
            if save_path.exists():
                 print(f"  â™»ï¸  Using cached: {filename}")
                 return f"![{subject}](/data/output/assets/ai_generated/{filename})"

            success = generate_nano_banana_image(subject, theme_config, save_path)
            
            if success:
                # Return strict relative path for Markdown
                return f"![{subject}](/data/output/assets/ai_generated/{filename})"
            else:
                return f"*[Image generation failed for: {subject}]*"
                
        except json.JSONDecodeError:
            print("  âš ï¸ Malformed JSON in NEW_DIAGRAM tag")
            return "*[Malformed Art Request]*"

    return re.sub(pattern, replacement_func, text)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TASK C: Master Function
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def process_art_department(expanded_text: str, style_config: dict = None) -> str:
    """
    Run the full Art Department pipeline:
      1. Resolve [ORIGINAL_ASSET] â†’ Markdown images
      2. Resolve [NEW_DIAGRAM]    â†’ AI Generated Images
      3. Save to ``resolved_manuscript.md``
    """
    print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("  ART DEPARTMENT â€” Processing tagsâ€¦")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

    # Step 1: Original assets
    text = resolve_original_assets(expanded_text)

    # Step 2: New diagrams (AI Generation)
    text = resolve_art_tags(text, style_config)

    # Step 3: Save
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    RESOLVED_PATH.write_text(text, encoding="utf-8")

    print(f"\n[Art Dept] âœ… Resolved manuscript saved ({len(text):,} chars) â†’ {RESOLVED_PATH}")

    return text


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CLI ENTRY POINT
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    import sys
    # For testing, we can accept a style JSON as 2nd arg
    input_path = sys.argv[1] if len(sys.argv) > 1 else "data/output/tagged_manuscript.txt"
    text = Path(input_path).read_text(encoding="utf-8")
    process_art_department(text)
